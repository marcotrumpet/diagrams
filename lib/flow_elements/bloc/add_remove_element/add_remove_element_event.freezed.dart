// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'add_remove_element_event.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$AbstractAddRemoveElementEventTearOff {
  const _$AbstractAddRemoveElementEventTearOff();

  _AbstractAddRemoveElementEvent call() {
    return const _AbstractAddRemoveElementEvent();
  }
}

/// @nodoc
const $AbstractAddRemoveElementEvent = _$AbstractAddRemoveElementEventTearOff();

/// @nodoc
mixin _$AbstractAddRemoveElementEvent {}

/// @nodoc
abstract class $AbstractAddRemoveElementEventCopyWith<$Res> {
  factory $AbstractAddRemoveElementEventCopyWith(
          AbstractAddRemoveElementEvent value,
          $Res Function(AbstractAddRemoveElementEvent) then) =
      _$AbstractAddRemoveElementEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$AbstractAddRemoveElementEventCopyWithImpl<$Res>
    implements $AbstractAddRemoveElementEventCopyWith<$Res> {
  _$AbstractAddRemoveElementEventCopyWithImpl(this._value, this._then);

  final AbstractAddRemoveElementEvent _value;
  // ignore: unused_field
  final $Res Function(AbstractAddRemoveElementEvent) _then;
}

/// @nodoc
abstract class _$AbstractAddRemoveElementEventCopyWith<$Res> {
  factory _$AbstractAddRemoveElementEventCopyWith(
          _AbstractAddRemoveElementEvent value,
          $Res Function(_AbstractAddRemoveElementEvent) then) =
      __$AbstractAddRemoveElementEventCopyWithImpl<$Res>;
}

/// @nodoc
class __$AbstractAddRemoveElementEventCopyWithImpl<$Res>
    extends _$AbstractAddRemoveElementEventCopyWithImpl<$Res>
    implements _$AbstractAddRemoveElementEventCopyWith<$Res> {
  __$AbstractAddRemoveElementEventCopyWithImpl(
      _AbstractAddRemoveElementEvent _value,
      $Res Function(_AbstractAddRemoveElementEvent) _then)
      : super(_value, (v) => _then(v as _AbstractAddRemoveElementEvent));

  @override
  _AbstractAddRemoveElementEvent get _value =>
      super._value as _AbstractAddRemoveElementEvent;
}

/// @nodoc

class _$_AbstractAddRemoveElementEvent
    with DiagnosticableTreeMixin
    implements _AbstractAddRemoveElementEvent {
  const _$_AbstractAddRemoveElementEvent();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AbstractAddRemoveElementEvent()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AbstractAddRemoveElementEvent'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _AbstractAddRemoveElementEvent);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class _AbstractAddRemoveElementEvent
    implements AbstractAddRemoveElementEvent {
  const factory _AbstractAddRemoveElementEvent() =
      _$_AbstractAddRemoveElementEvent;
}

/// @nodoc
class _$AddElementEventTearOff {
  const _$AddElementEventTearOff();

  _AddElementEvent call({required AbstractFlowElement elementToManipulate}) {
    return _AddElementEvent(
      elementToManipulate: elementToManipulate,
    );
  }
}

/// @nodoc
const $AddElementEvent = _$AddElementEventTearOff();

/// @nodoc
mixin _$AddElementEvent {
  AbstractFlowElement get elementToManipulate =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $AddElementEventCopyWith<AddElementEvent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AddElementEventCopyWith<$Res> {
  factory $AddElementEventCopyWith(
          AddElementEvent value, $Res Function(AddElementEvent) then) =
      _$AddElementEventCopyWithImpl<$Res>;
  $Res call({AbstractFlowElement elementToManipulate});
}

/// @nodoc
class _$AddElementEventCopyWithImpl<$Res>
    implements $AddElementEventCopyWith<$Res> {
  _$AddElementEventCopyWithImpl(this._value, this._then);

  final AddElementEvent _value;
  // ignore: unused_field
  final $Res Function(AddElementEvent) _then;

  @override
  $Res call({
    Object? elementToManipulate = freezed,
  }) {
    return _then(_value.copyWith(
      elementToManipulate: elementToManipulate == freezed
          ? _value.elementToManipulate
          : elementToManipulate // ignore: cast_nullable_to_non_nullable
              as AbstractFlowElement,
    ));
  }
}

/// @nodoc
abstract class _$AddElementEventCopyWith<$Res>
    implements $AddElementEventCopyWith<$Res> {
  factory _$AddElementEventCopyWith(
          _AddElementEvent value, $Res Function(_AddElementEvent) then) =
      __$AddElementEventCopyWithImpl<$Res>;
  @override
  $Res call({AbstractFlowElement elementToManipulate});
}

/// @nodoc
class __$AddElementEventCopyWithImpl<$Res>
    extends _$AddElementEventCopyWithImpl<$Res>
    implements _$AddElementEventCopyWith<$Res> {
  __$AddElementEventCopyWithImpl(
      _AddElementEvent _value, $Res Function(_AddElementEvent) _then)
      : super(_value, (v) => _then(v as _AddElementEvent));

  @override
  _AddElementEvent get _value => super._value as _AddElementEvent;

  @override
  $Res call({
    Object? elementToManipulate = freezed,
  }) {
    return _then(_AddElementEvent(
      elementToManipulate: elementToManipulate == freezed
          ? _value.elementToManipulate
          : elementToManipulate // ignore: cast_nullable_to_non_nullable
              as AbstractFlowElement,
    ));
  }
}

/// @nodoc

class _$_AddElementEvent
    with DiagnosticableTreeMixin
    implements _AddElementEvent {
  const _$_AddElementEvent({required this.elementToManipulate});

  @override
  final AbstractFlowElement elementToManipulate;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AddElementEvent(elementToManipulate: $elementToManipulate)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AddElementEvent'))
      ..add(DiagnosticsProperty('elementToManipulate', elementToManipulate));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _AddElementEvent &&
            const DeepCollectionEquality()
                .equals(other.elementToManipulate, elementToManipulate));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(elementToManipulate));

  @JsonKey(ignore: true)
  @override
  _$AddElementEventCopyWith<_AddElementEvent> get copyWith =>
      __$AddElementEventCopyWithImpl<_AddElementEvent>(this, _$identity);
}

abstract class _AddElementEvent implements AddElementEvent {
  const factory _AddElementEvent(
      {required AbstractFlowElement elementToManipulate}) = _$_AddElementEvent;

  @override
  AbstractFlowElement get elementToManipulate;
  @override
  @JsonKey(ignore: true)
  _$AddElementEventCopyWith<_AddElementEvent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$RemoveElementEventTearOff {
  const _$RemoveElementEventTearOff();

  _RemoveElementEvent call({required AbstractFlowElement elementToManipulate}) {
    return _RemoveElementEvent(
      elementToManipulate: elementToManipulate,
    );
  }
}

/// @nodoc
const $RemoveElementEvent = _$RemoveElementEventTearOff();

/// @nodoc
mixin _$RemoveElementEvent {
  AbstractFlowElement get elementToManipulate =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $RemoveElementEventCopyWith<RemoveElementEvent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RemoveElementEventCopyWith<$Res> {
  factory $RemoveElementEventCopyWith(
          RemoveElementEvent value, $Res Function(RemoveElementEvent) then) =
      _$RemoveElementEventCopyWithImpl<$Res>;
  $Res call({AbstractFlowElement elementToManipulate});
}

/// @nodoc
class _$RemoveElementEventCopyWithImpl<$Res>
    implements $RemoveElementEventCopyWith<$Res> {
  _$RemoveElementEventCopyWithImpl(this._value, this._then);

  final RemoveElementEvent _value;
  // ignore: unused_field
  final $Res Function(RemoveElementEvent) _then;

  @override
  $Res call({
    Object? elementToManipulate = freezed,
  }) {
    return _then(_value.copyWith(
      elementToManipulate: elementToManipulate == freezed
          ? _value.elementToManipulate
          : elementToManipulate // ignore: cast_nullable_to_non_nullable
              as AbstractFlowElement,
    ));
  }
}

/// @nodoc
abstract class _$RemoveElementEventCopyWith<$Res>
    implements $RemoveElementEventCopyWith<$Res> {
  factory _$RemoveElementEventCopyWith(
          _RemoveElementEvent value, $Res Function(_RemoveElementEvent) then) =
      __$RemoveElementEventCopyWithImpl<$Res>;
  @override
  $Res call({AbstractFlowElement elementToManipulate});
}

/// @nodoc
class __$RemoveElementEventCopyWithImpl<$Res>
    extends _$RemoveElementEventCopyWithImpl<$Res>
    implements _$RemoveElementEventCopyWith<$Res> {
  __$RemoveElementEventCopyWithImpl(
      _RemoveElementEvent _value, $Res Function(_RemoveElementEvent) _then)
      : super(_value, (v) => _then(v as _RemoveElementEvent));

  @override
  _RemoveElementEvent get _value => super._value as _RemoveElementEvent;

  @override
  $Res call({
    Object? elementToManipulate = freezed,
  }) {
    return _then(_RemoveElementEvent(
      elementToManipulate: elementToManipulate == freezed
          ? _value.elementToManipulate
          : elementToManipulate // ignore: cast_nullable_to_non_nullable
              as AbstractFlowElement,
    ));
  }
}

/// @nodoc

class _$_RemoveElementEvent
    with DiagnosticableTreeMixin
    implements _RemoveElementEvent {
  const _$_RemoveElementEvent({required this.elementToManipulate});

  @override
  final AbstractFlowElement elementToManipulate;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'RemoveElementEvent(elementToManipulate: $elementToManipulate)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'RemoveElementEvent'))
      ..add(DiagnosticsProperty('elementToManipulate', elementToManipulate));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _RemoveElementEvent &&
            const DeepCollectionEquality()
                .equals(other.elementToManipulate, elementToManipulate));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(elementToManipulate));

  @JsonKey(ignore: true)
  @override
  _$RemoveElementEventCopyWith<_RemoveElementEvent> get copyWith =>
      __$RemoveElementEventCopyWithImpl<_RemoveElementEvent>(this, _$identity);
}

abstract class _RemoveElementEvent implements RemoveElementEvent {
  const factory _RemoveElementEvent(
          {required AbstractFlowElement elementToManipulate}) =
      _$_RemoveElementEvent;

  @override
  AbstractFlowElement get elementToManipulate;
  @override
  @JsonKey(ignore: true)
  _$RemoveElementEventCopyWith<_RemoveElementEvent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$MoveElementEventTearOff {
  const _$MoveElementEventTearOff();

  _MoveElementEvent call({required AbstractFlowElement elementToManipulate}) {
    return _MoveElementEvent(
      elementToManipulate: elementToManipulate,
    );
  }
}

/// @nodoc
const $MoveElementEvent = _$MoveElementEventTearOff();

/// @nodoc
mixin _$MoveElementEvent {
  AbstractFlowElement get elementToManipulate =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $MoveElementEventCopyWith<MoveElementEvent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MoveElementEventCopyWith<$Res> {
  factory $MoveElementEventCopyWith(
          MoveElementEvent value, $Res Function(MoveElementEvent) then) =
      _$MoveElementEventCopyWithImpl<$Res>;
  $Res call({AbstractFlowElement elementToManipulate});
}

/// @nodoc
class _$MoveElementEventCopyWithImpl<$Res>
    implements $MoveElementEventCopyWith<$Res> {
  _$MoveElementEventCopyWithImpl(this._value, this._then);

  final MoveElementEvent _value;
  // ignore: unused_field
  final $Res Function(MoveElementEvent) _then;

  @override
  $Res call({
    Object? elementToManipulate = freezed,
  }) {
    return _then(_value.copyWith(
      elementToManipulate: elementToManipulate == freezed
          ? _value.elementToManipulate
          : elementToManipulate // ignore: cast_nullable_to_non_nullable
              as AbstractFlowElement,
    ));
  }
}

/// @nodoc
abstract class _$MoveElementEventCopyWith<$Res>
    implements $MoveElementEventCopyWith<$Res> {
  factory _$MoveElementEventCopyWith(
          _MoveElementEvent value, $Res Function(_MoveElementEvent) then) =
      __$MoveElementEventCopyWithImpl<$Res>;
  @override
  $Res call({AbstractFlowElement elementToManipulate});
}

/// @nodoc
class __$MoveElementEventCopyWithImpl<$Res>
    extends _$MoveElementEventCopyWithImpl<$Res>
    implements _$MoveElementEventCopyWith<$Res> {
  __$MoveElementEventCopyWithImpl(
      _MoveElementEvent _value, $Res Function(_MoveElementEvent) _then)
      : super(_value, (v) => _then(v as _MoveElementEvent));

  @override
  _MoveElementEvent get _value => super._value as _MoveElementEvent;

  @override
  $Res call({
    Object? elementToManipulate = freezed,
  }) {
    return _then(_MoveElementEvent(
      elementToManipulate: elementToManipulate == freezed
          ? _value.elementToManipulate
          : elementToManipulate // ignore: cast_nullable_to_non_nullable
              as AbstractFlowElement,
    ));
  }
}

/// @nodoc

class _$_MoveElementEvent
    with DiagnosticableTreeMixin
    implements _MoveElementEvent {
  const _$_MoveElementEvent({required this.elementToManipulate});

  @override
  final AbstractFlowElement elementToManipulate;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'MoveElementEvent(elementToManipulate: $elementToManipulate)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'MoveElementEvent'))
      ..add(DiagnosticsProperty('elementToManipulate', elementToManipulate));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _MoveElementEvent &&
            const DeepCollectionEquality()
                .equals(other.elementToManipulate, elementToManipulate));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(elementToManipulate));

  @JsonKey(ignore: true)
  @override
  _$MoveElementEventCopyWith<_MoveElementEvent> get copyWith =>
      __$MoveElementEventCopyWithImpl<_MoveElementEvent>(this, _$identity);
}

abstract class _MoveElementEvent implements MoveElementEvent {
  const factory _MoveElementEvent(
      {required AbstractFlowElement elementToManipulate}) = _$_MoveElementEvent;

  @override
  AbstractFlowElement get elementToManipulate;
  @override
  @JsonKey(ignore: true)
  _$MoveElementEventCopyWith<_MoveElementEvent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$AddStartingPointToAnchorElementEventTearOff {
  const _$AddStartingPointToAnchorElementEventTearOff();

  _AddStartingPointToAnchorElementEvent call(
      {required AbstractFlowElement elementToManipulate,
      required ArrowModel arrowModelLinkedToElement}) {
    return _AddStartingPointToAnchorElementEvent(
      elementToManipulate: elementToManipulate,
      arrowModelLinkedToElement: arrowModelLinkedToElement,
    );
  }
}

/// @nodoc
const $AddStartingPointToAnchorElementEvent =
    _$AddStartingPointToAnchorElementEventTearOff();

/// @nodoc
mixin _$AddStartingPointToAnchorElementEvent {
  AbstractFlowElement get elementToManipulate =>
      throw _privateConstructorUsedError;
  ArrowModel get arrowModelLinkedToElement =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $AddStartingPointToAnchorElementEventCopyWith<
          AddStartingPointToAnchorElementEvent>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AddStartingPointToAnchorElementEventCopyWith<$Res> {
  factory $AddStartingPointToAnchorElementEventCopyWith(
          AddStartingPointToAnchorElementEvent value,
          $Res Function(AddStartingPointToAnchorElementEvent) then) =
      _$AddStartingPointToAnchorElementEventCopyWithImpl<$Res>;
  $Res call(
      {AbstractFlowElement elementToManipulate,
      ArrowModel arrowModelLinkedToElement});

  $ArrowModelCopyWith<$Res> get arrowModelLinkedToElement;
}

/// @nodoc
class _$AddStartingPointToAnchorElementEventCopyWithImpl<$Res>
    implements $AddStartingPointToAnchorElementEventCopyWith<$Res> {
  _$AddStartingPointToAnchorElementEventCopyWithImpl(this._value, this._then);

  final AddStartingPointToAnchorElementEvent _value;
  // ignore: unused_field
  final $Res Function(AddStartingPointToAnchorElementEvent) _then;

  @override
  $Res call({
    Object? elementToManipulate = freezed,
    Object? arrowModelLinkedToElement = freezed,
  }) {
    return _then(_value.copyWith(
      elementToManipulate: elementToManipulate == freezed
          ? _value.elementToManipulate
          : elementToManipulate // ignore: cast_nullable_to_non_nullable
              as AbstractFlowElement,
      arrowModelLinkedToElement: arrowModelLinkedToElement == freezed
          ? _value.arrowModelLinkedToElement
          : arrowModelLinkedToElement // ignore: cast_nullable_to_non_nullable
              as ArrowModel,
    ));
  }

  @override
  $ArrowModelCopyWith<$Res> get arrowModelLinkedToElement {
    return $ArrowModelCopyWith<$Res>(_value.arrowModelLinkedToElement, (value) {
      return _then(_value.copyWith(arrowModelLinkedToElement: value));
    });
  }
}

/// @nodoc
abstract class _$AddStartingPointToAnchorElementEventCopyWith<$Res>
    implements $AddStartingPointToAnchorElementEventCopyWith<$Res> {
  factory _$AddStartingPointToAnchorElementEventCopyWith(
          _AddStartingPointToAnchorElementEvent value,
          $Res Function(_AddStartingPointToAnchorElementEvent) then) =
      __$AddStartingPointToAnchorElementEventCopyWithImpl<$Res>;
  @override
  $Res call(
      {AbstractFlowElement elementToManipulate,
      ArrowModel arrowModelLinkedToElement});

  @override
  $ArrowModelCopyWith<$Res> get arrowModelLinkedToElement;
}

/// @nodoc
class __$AddStartingPointToAnchorElementEventCopyWithImpl<$Res>
    extends _$AddStartingPointToAnchorElementEventCopyWithImpl<$Res>
    implements _$AddStartingPointToAnchorElementEventCopyWith<$Res> {
  __$AddStartingPointToAnchorElementEventCopyWithImpl(
      _AddStartingPointToAnchorElementEvent _value,
      $Res Function(_AddStartingPointToAnchorElementEvent) _then)
      : super(_value, (v) => _then(v as _AddStartingPointToAnchorElementEvent));

  @override
  _AddStartingPointToAnchorElementEvent get _value =>
      super._value as _AddStartingPointToAnchorElementEvent;

  @override
  $Res call({
    Object? elementToManipulate = freezed,
    Object? arrowModelLinkedToElement = freezed,
  }) {
    return _then(_AddStartingPointToAnchorElementEvent(
      elementToManipulate: elementToManipulate == freezed
          ? _value.elementToManipulate
          : elementToManipulate // ignore: cast_nullable_to_non_nullable
              as AbstractFlowElement,
      arrowModelLinkedToElement: arrowModelLinkedToElement == freezed
          ? _value.arrowModelLinkedToElement
          : arrowModelLinkedToElement // ignore: cast_nullable_to_non_nullable
              as ArrowModel,
    ));
  }
}

/// @nodoc

class _$_AddStartingPointToAnchorElementEvent
    with DiagnosticableTreeMixin
    implements _AddStartingPointToAnchorElementEvent {
  const _$_AddStartingPointToAnchorElementEvent(
      {required this.elementToManipulate,
      required this.arrowModelLinkedToElement});

  @override
  final AbstractFlowElement elementToManipulate;
  @override
  final ArrowModel arrowModelLinkedToElement;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AddStartingPointToAnchorElementEvent(elementToManipulate: $elementToManipulate, arrowModelLinkedToElement: $arrowModelLinkedToElement)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AddStartingPointToAnchorElementEvent'))
      ..add(DiagnosticsProperty('elementToManipulate', elementToManipulate))
      ..add(DiagnosticsProperty(
          'arrowModelLinkedToElement', arrowModelLinkedToElement));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _AddStartingPointToAnchorElementEvent &&
            const DeepCollectionEquality()
                .equals(other.elementToManipulate, elementToManipulate) &&
            const DeepCollectionEquality().equals(
                other.arrowModelLinkedToElement, arrowModelLinkedToElement));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(elementToManipulate),
      const DeepCollectionEquality().hash(arrowModelLinkedToElement));

  @JsonKey(ignore: true)
  @override
  _$AddStartingPointToAnchorElementEventCopyWith<
          _AddStartingPointToAnchorElementEvent>
      get copyWith => __$AddStartingPointToAnchorElementEventCopyWithImpl<
          _AddStartingPointToAnchorElementEvent>(this, _$identity);
}

abstract class _AddStartingPointToAnchorElementEvent
    implements AddStartingPointToAnchorElementEvent {
  const factory _AddStartingPointToAnchorElementEvent(
          {required AbstractFlowElement elementToManipulate,
          required ArrowModel arrowModelLinkedToElement}) =
      _$_AddStartingPointToAnchorElementEvent;

  @override
  AbstractFlowElement get elementToManipulate;
  @override
  ArrowModel get arrowModelLinkedToElement;
  @override
  @JsonKey(ignore: true)
  _$AddStartingPointToAnchorElementEventCopyWith<
          _AddStartingPointToAnchorElementEvent>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
class _$AddEndingPointToAnchorElementEventTearOff {
  const _$AddEndingPointToAnchorElementEventTearOff();

  _AddEndingPointToAnchorElementEvent call(
      {required AbstractFlowElement elementToManipulate,
      required ArrowModel arrowModelLinkedToElement}) {
    return _AddEndingPointToAnchorElementEvent(
      elementToManipulate: elementToManipulate,
      arrowModelLinkedToElement: arrowModelLinkedToElement,
    );
  }
}

/// @nodoc
const $AddEndingPointToAnchorElementEvent =
    _$AddEndingPointToAnchorElementEventTearOff();

/// @nodoc
mixin _$AddEndingPointToAnchorElementEvent {
  AbstractFlowElement get elementToManipulate =>
      throw _privateConstructorUsedError;
  ArrowModel get arrowModelLinkedToElement =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $AddEndingPointToAnchorElementEventCopyWith<
          AddEndingPointToAnchorElementEvent>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AddEndingPointToAnchorElementEventCopyWith<$Res> {
  factory $AddEndingPointToAnchorElementEventCopyWith(
          AddEndingPointToAnchorElementEvent value,
          $Res Function(AddEndingPointToAnchorElementEvent) then) =
      _$AddEndingPointToAnchorElementEventCopyWithImpl<$Res>;
  $Res call(
      {AbstractFlowElement elementToManipulate,
      ArrowModel arrowModelLinkedToElement});

  $ArrowModelCopyWith<$Res> get arrowModelLinkedToElement;
}

/// @nodoc
class _$AddEndingPointToAnchorElementEventCopyWithImpl<$Res>
    implements $AddEndingPointToAnchorElementEventCopyWith<$Res> {
  _$AddEndingPointToAnchorElementEventCopyWithImpl(this._value, this._then);

  final AddEndingPointToAnchorElementEvent _value;
  // ignore: unused_field
  final $Res Function(AddEndingPointToAnchorElementEvent) _then;

  @override
  $Res call({
    Object? elementToManipulate = freezed,
    Object? arrowModelLinkedToElement = freezed,
  }) {
    return _then(_value.copyWith(
      elementToManipulate: elementToManipulate == freezed
          ? _value.elementToManipulate
          : elementToManipulate // ignore: cast_nullable_to_non_nullable
              as AbstractFlowElement,
      arrowModelLinkedToElement: arrowModelLinkedToElement == freezed
          ? _value.arrowModelLinkedToElement
          : arrowModelLinkedToElement // ignore: cast_nullable_to_non_nullable
              as ArrowModel,
    ));
  }

  @override
  $ArrowModelCopyWith<$Res> get arrowModelLinkedToElement {
    return $ArrowModelCopyWith<$Res>(_value.arrowModelLinkedToElement, (value) {
      return _then(_value.copyWith(arrowModelLinkedToElement: value));
    });
  }
}

/// @nodoc
abstract class _$AddEndingPointToAnchorElementEventCopyWith<$Res>
    implements $AddEndingPointToAnchorElementEventCopyWith<$Res> {
  factory _$AddEndingPointToAnchorElementEventCopyWith(
          _AddEndingPointToAnchorElementEvent value,
          $Res Function(_AddEndingPointToAnchorElementEvent) then) =
      __$AddEndingPointToAnchorElementEventCopyWithImpl<$Res>;
  @override
  $Res call(
      {AbstractFlowElement elementToManipulate,
      ArrowModel arrowModelLinkedToElement});

  @override
  $ArrowModelCopyWith<$Res> get arrowModelLinkedToElement;
}

/// @nodoc
class __$AddEndingPointToAnchorElementEventCopyWithImpl<$Res>
    extends _$AddEndingPointToAnchorElementEventCopyWithImpl<$Res>
    implements _$AddEndingPointToAnchorElementEventCopyWith<$Res> {
  __$AddEndingPointToAnchorElementEventCopyWithImpl(
      _AddEndingPointToAnchorElementEvent _value,
      $Res Function(_AddEndingPointToAnchorElementEvent) _then)
      : super(_value, (v) => _then(v as _AddEndingPointToAnchorElementEvent));

  @override
  _AddEndingPointToAnchorElementEvent get _value =>
      super._value as _AddEndingPointToAnchorElementEvent;

  @override
  $Res call({
    Object? elementToManipulate = freezed,
    Object? arrowModelLinkedToElement = freezed,
  }) {
    return _then(_AddEndingPointToAnchorElementEvent(
      elementToManipulate: elementToManipulate == freezed
          ? _value.elementToManipulate
          : elementToManipulate // ignore: cast_nullable_to_non_nullable
              as AbstractFlowElement,
      arrowModelLinkedToElement: arrowModelLinkedToElement == freezed
          ? _value.arrowModelLinkedToElement
          : arrowModelLinkedToElement // ignore: cast_nullable_to_non_nullable
              as ArrowModel,
    ));
  }
}

/// @nodoc

class _$_AddEndingPointToAnchorElementEvent
    with DiagnosticableTreeMixin
    implements _AddEndingPointToAnchorElementEvent {
  const _$_AddEndingPointToAnchorElementEvent(
      {required this.elementToManipulate,
      required this.arrowModelLinkedToElement});

  @override
  final AbstractFlowElement elementToManipulate;
  @override
  final ArrowModel arrowModelLinkedToElement;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AddEndingPointToAnchorElementEvent(elementToManipulate: $elementToManipulate, arrowModelLinkedToElement: $arrowModelLinkedToElement)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AddEndingPointToAnchorElementEvent'))
      ..add(DiagnosticsProperty('elementToManipulate', elementToManipulate))
      ..add(DiagnosticsProperty(
          'arrowModelLinkedToElement', arrowModelLinkedToElement));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _AddEndingPointToAnchorElementEvent &&
            const DeepCollectionEquality()
                .equals(other.elementToManipulate, elementToManipulate) &&
            const DeepCollectionEquality().equals(
                other.arrowModelLinkedToElement, arrowModelLinkedToElement));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(elementToManipulate),
      const DeepCollectionEquality().hash(arrowModelLinkedToElement));

  @JsonKey(ignore: true)
  @override
  _$AddEndingPointToAnchorElementEventCopyWith<
          _AddEndingPointToAnchorElementEvent>
      get copyWith => __$AddEndingPointToAnchorElementEventCopyWithImpl<
          _AddEndingPointToAnchorElementEvent>(this, _$identity);
}

abstract class _AddEndingPointToAnchorElementEvent
    implements AddEndingPointToAnchorElementEvent {
  const factory _AddEndingPointToAnchorElementEvent(
          {required AbstractFlowElement elementToManipulate,
          required ArrowModel arrowModelLinkedToElement}) =
      _$_AddEndingPointToAnchorElementEvent;

  @override
  AbstractFlowElement get elementToManipulate;
  @override
  ArrowModel get arrowModelLinkedToElement;
  @override
  @JsonKey(ignore: true)
  _$AddEndingPointToAnchorElementEventCopyWith<
          _AddEndingPointToAnchorElementEvent>
      get copyWith => throw _privateConstructorUsedError;
}
