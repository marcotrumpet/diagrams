// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'draw_arrows_event.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$AbstractDrawArrowsEventTearOff {
  const _$AbstractDrawArrowsEventTearOff();

  _AbstractDrawArrowsEvent call() {
    return const _AbstractDrawArrowsEvent();
  }
}

/// @nodoc
const $AbstractDrawArrowsEvent = _$AbstractDrawArrowsEventTearOff();

/// @nodoc
mixin _$AbstractDrawArrowsEvent {}

/// @nodoc
abstract class $AbstractDrawArrowsEventCopyWith<$Res> {
  factory $AbstractDrawArrowsEventCopyWith(AbstractDrawArrowsEvent value,
          $Res Function(AbstractDrawArrowsEvent) then) =
      _$AbstractDrawArrowsEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$AbstractDrawArrowsEventCopyWithImpl<$Res>
    implements $AbstractDrawArrowsEventCopyWith<$Res> {
  _$AbstractDrawArrowsEventCopyWithImpl(this._value, this._then);

  final AbstractDrawArrowsEvent _value;
  // ignore: unused_field
  final $Res Function(AbstractDrawArrowsEvent) _then;
}

/// @nodoc
abstract class _$AbstractDrawArrowsEventCopyWith<$Res> {
  factory _$AbstractDrawArrowsEventCopyWith(_AbstractDrawArrowsEvent value,
          $Res Function(_AbstractDrawArrowsEvent) then) =
      __$AbstractDrawArrowsEventCopyWithImpl<$Res>;
}

/// @nodoc
class __$AbstractDrawArrowsEventCopyWithImpl<$Res>
    extends _$AbstractDrawArrowsEventCopyWithImpl<$Res>
    implements _$AbstractDrawArrowsEventCopyWith<$Res> {
  __$AbstractDrawArrowsEventCopyWithImpl(_AbstractDrawArrowsEvent _value,
      $Res Function(_AbstractDrawArrowsEvent) _then)
      : super(_value, (v) => _then(v as _AbstractDrawArrowsEvent));

  @override
  _AbstractDrawArrowsEvent get _value =>
      super._value as _AbstractDrawArrowsEvent;
}

/// @nodoc

class _$_AbstractDrawArrowsEvent
    with DiagnosticableTreeMixin
    implements _AbstractDrawArrowsEvent {
  const _$_AbstractDrawArrowsEvent();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AbstractDrawArrowsEvent()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'AbstractDrawArrowsEvent'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _AbstractDrawArrowsEvent);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class _AbstractDrawArrowsEvent implements AbstractDrawArrowsEvent {
  const factory _AbstractDrawArrowsEvent() = _$_AbstractDrawArrowsEvent;
}

/// @nodoc
class _$StartNewArrowEventTearOff {
  const _$StartNewArrowEventTearOff();

  _StartNewArrowEvent call({required ArrowModel arrowModel}) {
    return _StartNewArrowEvent(
      arrowModel: arrowModel,
    );
  }
}

/// @nodoc
const $StartNewArrowEvent = _$StartNewArrowEventTearOff();

/// @nodoc
mixin _$StartNewArrowEvent {
  ArrowModel get arrowModel => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $StartNewArrowEventCopyWith<StartNewArrowEvent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StartNewArrowEventCopyWith<$Res> {
  factory $StartNewArrowEventCopyWith(
          StartNewArrowEvent value, $Res Function(StartNewArrowEvent) then) =
      _$StartNewArrowEventCopyWithImpl<$Res>;
  $Res call({ArrowModel arrowModel});

  $ArrowModelCopyWith<$Res> get arrowModel;
}

/// @nodoc
class _$StartNewArrowEventCopyWithImpl<$Res>
    implements $StartNewArrowEventCopyWith<$Res> {
  _$StartNewArrowEventCopyWithImpl(this._value, this._then);

  final StartNewArrowEvent _value;
  // ignore: unused_field
  final $Res Function(StartNewArrowEvent) _then;

  @override
  $Res call({
    Object? arrowModel = freezed,
  }) {
    return _then(_value.copyWith(
      arrowModel: arrowModel == freezed
          ? _value.arrowModel
          : arrowModel // ignore: cast_nullable_to_non_nullable
              as ArrowModel,
    ));
  }

  @override
  $ArrowModelCopyWith<$Res> get arrowModel {
    return $ArrowModelCopyWith<$Res>(_value.arrowModel, (value) {
      return _then(_value.copyWith(arrowModel: value));
    });
  }
}

/// @nodoc
abstract class _$StartNewArrowEventCopyWith<$Res>
    implements $StartNewArrowEventCopyWith<$Res> {
  factory _$StartNewArrowEventCopyWith(
          _StartNewArrowEvent value, $Res Function(_StartNewArrowEvent) then) =
      __$StartNewArrowEventCopyWithImpl<$Res>;
  @override
  $Res call({ArrowModel arrowModel});

  @override
  $ArrowModelCopyWith<$Res> get arrowModel;
}

/// @nodoc
class __$StartNewArrowEventCopyWithImpl<$Res>
    extends _$StartNewArrowEventCopyWithImpl<$Res>
    implements _$StartNewArrowEventCopyWith<$Res> {
  __$StartNewArrowEventCopyWithImpl(
      _StartNewArrowEvent _value, $Res Function(_StartNewArrowEvent) _then)
      : super(_value, (v) => _then(v as _StartNewArrowEvent));

  @override
  _StartNewArrowEvent get _value => super._value as _StartNewArrowEvent;

  @override
  $Res call({
    Object? arrowModel = freezed,
  }) {
    return _then(_StartNewArrowEvent(
      arrowModel: arrowModel == freezed
          ? _value.arrowModel
          : arrowModel // ignore: cast_nullable_to_non_nullable
              as ArrowModel,
    ));
  }
}

/// @nodoc

class _$_StartNewArrowEvent
    with DiagnosticableTreeMixin
    implements _StartNewArrowEvent {
  const _$_StartNewArrowEvent({required this.arrowModel});

  @override
  final ArrowModel arrowModel;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'StartNewArrowEvent(arrowModel: $arrowModel)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'StartNewArrowEvent'))
      ..add(DiagnosticsProperty('arrowModel', arrowModel));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _StartNewArrowEvent &&
            const DeepCollectionEquality()
                .equals(other.arrowModel, arrowModel));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(arrowModel));

  @JsonKey(ignore: true)
  @override
  _$StartNewArrowEventCopyWith<_StartNewArrowEvent> get copyWith =>
      __$StartNewArrowEventCopyWithImpl<_StartNewArrowEvent>(this, _$identity);
}

abstract class _StartNewArrowEvent implements StartNewArrowEvent {
  const factory _StartNewArrowEvent({required ArrowModel arrowModel}) =
      _$_StartNewArrowEvent;

  @override
  ArrowModel get arrowModel;
  @override
  @JsonKey(ignore: true)
  _$StartNewArrowEventCopyWith<_StartNewArrowEvent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$DrawArrowsEventTearOff {
  const _$DrawArrowsEventTearOff();

  _DrawArrowsEvent call(
      {Offset? startPoint,
      Offset? endPoint,
      Key? arrowKey,
      AbstractFlowElement? startElement,
      AbstractFlowElement? endElement,
      Key? startPointKey,
      Key? endPointKey}) {
    return _DrawArrowsEvent(
      startPoint: startPoint,
      endPoint: endPoint,
      arrowKey: arrowKey,
      startElement: startElement,
      endElement: endElement,
      startPointKey: startPointKey,
      endPointKey: endPointKey,
    );
  }
}

/// @nodoc
const $DrawArrowsEvent = _$DrawArrowsEventTearOff();

/// @nodoc
mixin _$DrawArrowsEvent {
  Offset? get startPoint => throw _privateConstructorUsedError;
  Offset? get endPoint => throw _privateConstructorUsedError;
  Key? get arrowKey => throw _privateConstructorUsedError;
  AbstractFlowElement? get startElement => throw _privateConstructorUsedError;
  AbstractFlowElement? get endElement => throw _privateConstructorUsedError;
  Key? get startPointKey => throw _privateConstructorUsedError;
  Key? get endPointKey => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $DrawArrowsEventCopyWith<DrawArrowsEvent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DrawArrowsEventCopyWith<$Res> {
  factory $DrawArrowsEventCopyWith(
          DrawArrowsEvent value, $Res Function(DrawArrowsEvent) then) =
      _$DrawArrowsEventCopyWithImpl<$Res>;
  $Res call(
      {Offset? startPoint,
      Offset? endPoint,
      Key? arrowKey,
      AbstractFlowElement? startElement,
      AbstractFlowElement? endElement,
      Key? startPointKey,
      Key? endPointKey});
}

/// @nodoc
class _$DrawArrowsEventCopyWithImpl<$Res>
    implements $DrawArrowsEventCopyWith<$Res> {
  _$DrawArrowsEventCopyWithImpl(this._value, this._then);

  final DrawArrowsEvent _value;
  // ignore: unused_field
  final $Res Function(DrawArrowsEvent) _then;

  @override
  $Res call({
    Object? startPoint = freezed,
    Object? endPoint = freezed,
    Object? arrowKey = freezed,
    Object? startElement = freezed,
    Object? endElement = freezed,
    Object? startPointKey = freezed,
    Object? endPointKey = freezed,
  }) {
    return _then(_value.copyWith(
      startPoint: startPoint == freezed
          ? _value.startPoint
          : startPoint // ignore: cast_nullable_to_non_nullable
              as Offset?,
      endPoint: endPoint == freezed
          ? _value.endPoint
          : endPoint // ignore: cast_nullable_to_non_nullable
              as Offset?,
      arrowKey: arrowKey == freezed
          ? _value.arrowKey
          : arrowKey // ignore: cast_nullable_to_non_nullable
              as Key?,
      startElement: startElement == freezed
          ? _value.startElement
          : startElement // ignore: cast_nullable_to_non_nullable
              as AbstractFlowElement?,
      endElement: endElement == freezed
          ? _value.endElement
          : endElement // ignore: cast_nullable_to_non_nullable
              as AbstractFlowElement?,
      startPointKey: startPointKey == freezed
          ? _value.startPointKey
          : startPointKey // ignore: cast_nullable_to_non_nullable
              as Key?,
      endPointKey: endPointKey == freezed
          ? _value.endPointKey
          : endPointKey // ignore: cast_nullable_to_non_nullable
              as Key?,
    ));
  }
}

/// @nodoc
abstract class _$DrawArrowsEventCopyWith<$Res>
    implements $DrawArrowsEventCopyWith<$Res> {
  factory _$DrawArrowsEventCopyWith(
          _DrawArrowsEvent value, $Res Function(_DrawArrowsEvent) then) =
      __$DrawArrowsEventCopyWithImpl<$Res>;
  @override
  $Res call(
      {Offset? startPoint,
      Offset? endPoint,
      Key? arrowKey,
      AbstractFlowElement? startElement,
      AbstractFlowElement? endElement,
      Key? startPointKey,
      Key? endPointKey});
}

/// @nodoc
class __$DrawArrowsEventCopyWithImpl<$Res>
    extends _$DrawArrowsEventCopyWithImpl<$Res>
    implements _$DrawArrowsEventCopyWith<$Res> {
  __$DrawArrowsEventCopyWithImpl(
      _DrawArrowsEvent _value, $Res Function(_DrawArrowsEvent) _then)
      : super(_value, (v) => _then(v as _DrawArrowsEvent));

  @override
  _DrawArrowsEvent get _value => super._value as _DrawArrowsEvent;

  @override
  $Res call({
    Object? startPoint = freezed,
    Object? endPoint = freezed,
    Object? arrowKey = freezed,
    Object? startElement = freezed,
    Object? endElement = freezed,
    Object? startPointKey = freezed,
    Object? endPointKey = freezed,
  }) {
    return _then(_DrawArrowsEvent(
      startPoint: startPoint == freezed
          ? _value.startPoint
          : startPoint // ignore: cast_nullable_to_non_nullable
              as Offset?,
      endPoint: endPoint == freezed
          ? _value.endPoint
          : endPoint // ignore: cast_nullable_to_non_nullable
              as Offset?,
      arrowKey: arrowKey == freezed
          ? _value.arrowKey
          : arrowKey // ignore: cast_nullable_to_non_nullable
              as Key?,
      startElement: startElement == freezed
          ? _value.startElement
          : startElement // ignore: cast_nullable_to_non_nullable
              as AbstractFlowElement?,
      endElement: endElement == freezed
          ? _value.endElement
          : endElement // ignore: cast_nullable_to_non_nullable
              as AbstractFlowElement?,
      startPointKey: startPointKey == freezed
          ? _value.startPointKey
          : startPointKey // ignore: cast_nullable_to_non_nullable
              as Key?,
      endPointKey: endPointKey == freezed
          ? _value.endPointKey
          : endPointKey // ignore: cast_nullable_to_non_nullable
              as Key?,
    ));
  }
}

/// @nodoc

class _$_DrawArrowsEvent
    with DiagnosticableTreeMixin
    implements _DrawArrowsEvent {
  const _$_DrawArrowsEvent(
      {this.startPoint,
      this.endPoint,
      this.arrowKey,
      this.startElement,
      this.endElement,
      this.startPointKey,
      this.endPointKey});

  @override
  final Offset? startPoint;
  @override
  final Offset? endPoint;
  @override
  final Key? arrowKey;
  @override
  final AbstractFlowElement? startElement;
  @override
  final AbstractFlowElement? endElement;
  @override
  final Key? startPointKey;
  @override
  final Key? endPointKey;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'DrawArrowsEvent(startPoint: $startPoint, endPoint: $endPoint, arrowKey: $arrowKey, startElement: $startElement, endElement: $endElement, startPointKey: $startPointKey, endPointKey: $endPointKey)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'DrawArrowsEvent'))
      ..add(DiagnosticsProperty('startPoint', startPoint))
      ..add(DiagnosticsProperty('endPoint', endPoint))
      ..add(DiagnosticsProperty('arrowKey', arrowKey))
      ..add(DiagnosticsProperty('startElement', startElement))
      ..add(DiagnosticsProperty('endElement', endElement))
      ..add(DiagnosticsProperty('startPointKey', startPointKey))
      ..add(DiagnosticsProperty('endPointKey', endPointKey));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _DrawArrowsEvent &&
            const DeepCollectionEquality()
                .equals(other.startPoint, startPoint) &&
            const DeepCollectionEquality().equals(other.endPoint, endPoint) &&
            const DeepCollectionEquality().equals(other.arrowKey, arrowKey) &&
            const DeepCollectionEquality()
                .equals(other.startElement, startElement) &&
            const DeepCollectionEquality()
                .equals(other.endElement, endElement) &&
            const DeepCollectionEquality()
                .equals(other.startPointKey, startPointKey) &&
            const DeepCollectionEquality()
                .equals(other.endPointKey, endPointKey));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(startPoint),
      const DeepCollectionEquality().hash(endPoint),
      const DeepCollectionEquality().hash(arrowKey),
      const DeepCollectionEquality().hash(startElement),
      const DeepCollectionEquality().hash(endElement),
      const DeepCollectionEquality().hash(startPointKey),
      const DeepCollectionEquality().hash(endPointKey));

  @JsonKey(ignore: true)
  @override
  _$DrawArrowsEventCopyWith<_DrawArrowsEvent> get copyWith =>
      __$DrawArrowsEventCopyWithImpl<_DrawArrowsEvent>(this, _$identity);
}

abstract class _DrawArrowsEvent implements DrawArrowsEvent {
  const factory _DrawArrowsEvent(
      {Offset? startPoint,
      Offset? endPoint,
      Key? arrowKey,
      AbstractFlowElement? startElement,
      AbstractFlowElement? endElement,
      Key? startPointKey,
      Key? endPointKey}) = _$_DrawArrowsEvent;

  @override
  Offset? get startPoint;
  @override
  Offset? get endPoint;
  @override
  Key? get arrowKey;
  @override
  AbstractFlowElement? get startElement;
  @override
  AbstractFlowElement? get endElement;
  @override
  Key? get startPointKey;
  @override
  Key? get endPointKey;
  @override
  @JsonKey(ignore: true)
  _$DrawArrowsEventCopyWith<_DrawArrowsEvent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$MovedFlowElementUpdateArrowsEventTearOff {
  const _$MovedFlowElementUpdateArrowsEventTearOff();

  _MovedFlowElementUpdateArrowsEvent call({AbstractFlowElement? element}) {
    return _MovedFlowElementUpdateArrowsEvent(
      element: element,
    );
  }
}

/// @nodoc
const $MovedFlowElementUpdateArrowsEvent =
    _$MovedFlowElementUpdateArrowsEventTearOff();

/// @nodoc
mixin _$MovedFlowElementUpdateArrowsEvent {
  AbstractFlowElement? get element => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $MovedFlowElementUpdateArrowsEventCopyWith<MovedFlowElementUpdateArrowsEvent>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MovedFlowElementUpdateArrowsEventCopyWith<$Res> {
  factory $MovedFlowElementUpdateArrowsEventCopyWith(
          MovedFlowElementUpdateArrowsEvent value,
          $Res Function(MovedFlowElementUpdateArrowsEvent) then) =
      _$MovedFlowElementUpdateArrowsEventCopyWithImpl<$Res>;
  $Res call({AbstractFlowElement? element});
}

/// @nodoc
class _$MovedFlowElementUpdateArrowsEventCopyWithImpl<$Res>
    implements $MovedFlowElementUpdateArrowsEventCopyWith<$Res> {
  _$MovedFlowElementUpdateArrowsEventCopyWithImpl(this._value, this._then);

  final MovedFlowElementUpdateArrowsEvent _value;
  // ignore: unused_field
  final $Res Function(MovedFlowElementUpdateArrowsEvent) _then;

  @override
  $Res call({
    Object? element = freezed,
  }) {
    return _then(_value.copyWith(
      element: element == freezed
          ? _value.element
          : element // ignore: cast_nullable_to_non_nullable
              as AbstractFlowElement?,
    ));
  }
}

/// @nodoc
abstract class _$MovedFlowElementUpdateArrowsEventCopyWith<$Res>
    implements $MovedFlowElementUpdateArrowsEventCopyWith<$Res> {
  factory _$MovedFlowElementUpdateArrowsEventCopyWith(
          _MovedFlowElementUpdateArrowsEvent value,
          $Res Function(_MovedFlowElementUpdateArrowsEvent) then) =
      __$MovedFlowElementUpdateArrowsEventCopyWithImpl<$Res>;
  @override
  $Res call({AbstractFlowElement? element});
}

/// @nodoc
class __$MovedFlowElementUpdateArrowsEventCopyWithImpl<$Res>
    extends _$MovedFlowElementUpdateArrowsEventCopyWithImpl<$Res>
    implements _$MovedFlowElementUpdateArrowsEventCopyWith<$Res> {
  __$MovedFlowElementUpdateArrowsEventCopyWithImpl(
      _MovedFlowElementUpdateArrowsEvent _value,
      $Res Function(_MovedFlowElementUpdateArrowsEvent) _then)
      : super(_value, (v) => _then(v as _MovedFlowElementUpdateArrowsEvent));

  @override
  _MovedFlowElementUpdateArrowsEvent get _value =>
      super._value as _MovedFlowElementUpdateArrowsEvent;

  @override
  $Res call({
    Object? element = freezed,
  }) {
    return _then(_MovedFlowElementUpdateArrowsEvent(
      element: element == freezed
          ? _value.element
          : element // ignore: cast_nullable_to_non_nullable
              as AbstractFlowElement?,
    ));
  }
}

/// @nodoc

class _$_MovedFlowElementUpdateArrowsEvent
    with DiagnosticableTreeMixin
    implements _MovedFlowElementUpdateArrowsEvent {
  const _$_MovedFlowElementUpdateArrowsEvent({this.element});

  @override
  final AbstractFlowElement? element;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'MovedFlowElementUpdateArrowsEvent(element: $element)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'MovedFlowElementUpdateArrowsEvent'))
      ..add(DiagnosticsProperty('element', element));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _MovedFlowElementUpdateArrowsEvent &&
            const DeepCollectionEquality().equals(other.element, element));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(element));

  @JsonKey(ignore: true)
  @override
  _$MovedFlowElementUpdateArrowsEventCopyWith<
          _MovedFlowElementUpdateArrowsEvent>
      get copyWith => __$MovedFlowElementUpdateArrowsEventCopyWithImpl<
          _MovedFlowElementUpdateArrowsEvent>(this, _$identity);
}

abstract class _MovedFlowElementUpdateArrowsEvent
    implements MovedFlowElementUpdateArrowsEvent {
  const factory _MovedFlowElementUpdateArrowsEvent(
      {AbstractFlowElement? element}) = _$_MovedFlowElementUpdateArrowsEvent;

  @override
  AbstractFlowElement? get element;
  @override
  @JsonKey(ignore: true)
  _$MovedFlowElementUpdateArrowsEventCopyWith<
          _MovedFlowElementUpdateArrowsEvent>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
class _$DrawArrowsAStarEventTearOff {
  const _$DrawArrowsAStarEventTearOff();

  _DrawArrowsAStarEvent call({ArrowModel? arrowModel}) {
    return _DrawArrowsAStarEvent(
      arrowModel: arrowModel,
    );
  }
}

/// @nodoc
const $DrawArrowsAStarEvent = _$DrawArrowsAStarEventTearOff();

/// @nodoc
mixin _$DrawArrowsAStarEvent {
  ArrowModel? get arrowModel => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $DrawArrowsAStarEventCopyWith<DrawArrowsAStarEvent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DrawArrowsAStarEventCopyWith<$Res> {
  factory $DrawArrowsAStarEventCopyWith(DrawArrowsAStarEvent value,
          $Res Function(DrawArrowsAStarEvent) then) =
      _$DrawArrowsAStarEventCopyWithImpl<$Res>;
  $Res call({ArrowModel? arrowModel});

  $ArrowModelCopyWith<$Res>? get arrowModel;
}

/// @nodoc
class _$DrawArrowsAStarEventCopyWithImpl<$Res>
    implements $DrawArrowsAStarEventCopyWith<$Res> {
  _$DrawArrowsAStarEventCopyWithImpl(this._value, this._then);

  final DrawArrowsAStarEvent _value;
  // ignore: unused_field
  final $Res Function(DrawArrowsAStarEvent) _then;

  @override
  $Res call({
    Object? arrowModel = freezed,
  }) {
    return _then(_value.copyWith(
      arrowModel: arrowModel == freezed
          ? _value.arrowModel
          : arrowModel // ignore: cast_nullable_to_non_nullable
              as ArrowModel?,
    ));
  }

  @override
  $ArrowModelCopyWith<$Res>? get arrowModel {
    if (_value.arrowModel == null) {
      return null;
    }

    return $ArrowModelCopyWith<$Res>(_value.arrowModel!, (value) {
      return _then(_value.copyWith(arrowModel: value));
    });
  }
}

/// @nodoc
abstract class _$DrawArrowsAStarEventCopyWith<$Res>
    implements $DrawArrowsAStarEventCopyWith<$Res> {
  factory _$DrawArrowsAStarEventCopyWith(_DrawArrowsAStarEvent value,
          $Res Function(_DrawArrowsAStarEvent) then) =
      __$DrawArrowsAStarEventCopyWithImpl<$Res>;
  @override
  $Res call({ArrowModel? arrowModel});

  @override
  $ArrowModelCopyWith<$Res>? get arrowModel;
}

/// @nodoc
class __$DrawArrowsAStarEventCopyWithImpl<$Res>
    extends _$DrawArrowsAStarEventCopyWithImpl<$Res>
    implements _$DrawArrowsAStarEventCopyWith<$Res> {
  __$DrawArrowsAStarEventCopyWithImpl(
      _DrawArrowsAStarEvent _value, $Res Function(_DrawArrowsAStarEvent) _then)
      : super(_value, (v) => _then(v as _DrawArrowsAStarEvent));

  @override
  _DrawArrowsAStarEvent get _value => super._value as _DrawArrowsAStarEvent;

  @override
  $Res call({
    Object? arrowModel = freezed,
  }) {
    return _then(_DrawArrowsAStarEvent(
      arrowModel: arrowModel == freezed
          ? _value.arrowModel
          : arrowModel // ignore: cast_nullable_to_non_nullable
              as ArrowModel?,
    ));
  }
}

/// @nodoc

class _$_DrawArrowsAStarEvent
    with DiagnosticableTreeMixin
    implements _DrawArrowsAStarEvent {
  const _$_DrawArrowsAStarEvent({this.arrowModel});

  @override
  final ArrowModel? arrowModel;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'DrawArrowsAStarEvent(arrowModel: $arrowModel)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'DrawArrowsAStarEvent'))
      ..add(DiagnosticsProperty('arrowModel', arrowModel));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _DrawArrowsAStarEvent &&
            const DeepCollectionEquality()
                .equals(other.arrowModel, arrowModel));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(arrowModel));

  @JsonKey(ignore: true)
  @override
  _$DrawArrowsAStarEventCopyWith<_DrawArrowsAStarEvent> get copyWith =>
      __$DrawArrowsAStarEventCopyWithImpl<_DrawArrowsAStarEvent>(
          this, _$identity);
}

abstract class _DrawArrowsAStarEvent implements DrawArrowsAStarEvent {
  const factory _DrawArrowsAStarEvent({ArrowModel? arrowModel}) =
      _$_DrawArrowsAStarEvent;

  @override
  ArrowModel? get arrowModel;
  @override
  @JsonKey(ignore: true)
  _$DrawArrowsAStarEventCopyWith<_DrawArrowsAStarEvent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$ResetArrowAStarStateEventTearOff {
  const _$ResetArrowAStarStateEventTearOff();

  _ResetArrowAStarStateEvent call({Key? arrowKey}) {
    return _ResetArrowAStarStateEvent(
      arrowKey: arrowKey,
    );
  }
}

/// @nodoc
const $ResetArrowAStarStateEvent = _$ResetArrowAStarStateEventTearOff();

/// @nodoc
mixin _$ResetArrowAStarStateEvent {
  Key? get arrowKey => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ResetArrowAStarStateEventCopyWith<ResetArrowAStarStateEvent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ResetArrowAStarStateEventCopyWith<$Res> {
  factory $ResetArrowAStarStateEventCopyWith(ResetArrowAStarStateEvent value,
          $Res Function(ResetArrowAStarStateEvent) then) =
      _$ResetArrowAStarStateEventCopyWithImpl<$Res>;
  $Res call({Key? arrowKey});
}

/// @nodoc
class _$ResetArrowAStarStateEventCopyWithImpl<$Res>
    implements $ResetArrowAStarStateEventCopyWith<$Res> {
  _$ResetArrowAStarStateEventCopyWithImpl(this._value, this._then);

  final ResetArrowAStarStateEvent _value;
  // ignore: unused_field
  final $Res Function(ResetArrowAStarStateEvent) _then;

  @override
  $Res call({
    Object? arrowKey = freezed,
  }) {
    return _then(_value.copyWith(
      arrowKey: arrowKey == freezed
          ? _value.arrowKey
          : arrowKey // ignore: cast_nullable_to_non_nullable
              as Key?,
    ));
  }
}

/// @nodoc
abstract class _$ResetArrowAStarStateEventCopyWith<$Res>
    implements $ResetArrowAStarStateEventCopyWith<$Res> {
  factory _$ResetArrowAStarStateEventCopyWith(_ResetArrowAStarStateEvent value,
          $Res Function(_ResetArrowAStarStateEvent) then) =
      __$ResetArrowAStarStateEventCopyWithImpl<$Res>;
  @override
  $Res call({Key? arrowKey});
}

/// @nodoc
class __$ResetArrowAStarStateEventCopyWithImpl<$Res>
    extends _$ResetArrowAStarStateEventCopyWithImpl<$Res>
    implements _$ResetArrowAStarStateEventCopyWith<$Res> {
  __$ResetArrowAStarStateEventCopyWithImpl(_ResetArrowAStarStateEvent _value,
      $Res Function(_ResetArrowAStarStateEvent) _then)
      : super(_value, (v) => _then(v as _ResetArrowAStarStateEvent));

  @override
  _ResetArrowAStarStateEvent get _value =>
      super._value as _ResetArrowAStarStateEvent;

  @override
  $Res call({
    Object? arrowKey = freezed,
  }) {
    return _then(_ResetArrowAStarStateEvent(
      arrowKey: arrowKey == freezed
          ? _value.arrowKey
          : arrowKey // ignore: cast_nullable_to_non_nullable
              as Key?,
    ));
  }
}

/// @nodoc

class _$_ResetArrowAStarStateEvent
    with DiagnosticableTreeMixin
    implements _ResetArrowAStarStateEvent {
  const _$_ResetArrowAStarStateEvent({this.arrowKey});

  @override
  final Key? arrowKey;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ResetArrowAStarStateEvent(arrowKey: $arrowKey)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ResetArrowAStarStateEvent'))
      ..add(DiagnosticsProperty('arrowKey', arrowKey));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ResetArrowAStarStateEvent &&
            const DeepCollectionEquality().equals(other.arrowKey, arrowKey));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(arrowKey));

  @JsonKey(ignore: true)
  @override
  _$ResetArrowAStarStateEventCopyWith<_ResetArrowAStarStateEvent>
      get copyWith =>
          __$ResetArrowAStarStateEventCopyWithImpl<_ResetArrowAStarStateEvent>(
              this, _$identity);
}

abstract class _ResetArrowAStarStateEvent implements ResetArrowAStarStateEvent {
  const factory _ResetArrowAStarStateEvent({Key? arrowKey}) =
      _$_ResetArrowAStarStateEvent;

  @override
  Key? get arrowKey;
  @override
  @JsonKey(ignore: true)
  _$ResetArrowAStarStateEventCopyWith<_ResetArrowAStarStateEvent>
      get copyWith => throw _privateConstructorUsedError;
}
