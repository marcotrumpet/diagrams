// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'open_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$OpenEventTearOff {
  const _$OpenEventTearOff();

  _Open open() {
    return const _Open();
  }
}

/// @nodoc
const $OpenEvent = _$OpenEventTearOff();

/// @nodoc
mixin _$OpenEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() open,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? open,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? open,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Open value) open,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Open value)? open,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Open value)? open,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $OpenEventCopyWith<$Res> {
  factory $OpenEventCopyWith(OpenEvent value, $Res Function(OpenEvent) then) =
      _$OpenEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$OpenEventCopyWithImpl<$Res> implements $OpenEventCopyWith<$Res> {
  _$OpenEventCopyWithImpl(this._value, this._then);

  final OpenEvent _value;
  // ignore: unused_field
  final $Res Function(OpenEvent) _then;
}

/// @nodoc
abstract class _$OpenCopyWith<$Res> {
  factory _$OpenCopyWith(_Open value, $Res Function(_Open) then) =
      __$OpenCopyWithImpl<$Res>;
}

/// @nodoc
class __$OpenCopyWithImpl<$Res> extends _$OpenEventCopyWithImpl<$Res>
    implements _$OpenCopyWith<$Res> {
  __$OpenCopyWithImpl(_Open _value, $Res Function(_Open) _then)
      : super(_value, (v) => _then(v as _Open));

  @override
  _Open get _value => super._value as _Open;
}

/// @nodoc

class _$_Open implements _Open {
  const _$_Open();

  @override
  String toString() {
    return 'OpenEvent.open()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _Open);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() open,
  }) {
    return open();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? open,
  }) {
    return open?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? open,
    required TResult orElse(),
  }) {
    if (open != null) {
      return open();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Open value) open,
  }) {
    return open(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Open value)? open,
  }) {
    return open?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Open value)? open,
    required TResult orElse(),
  }) {
    if (open != null) {
      return open(this);
    }
    return orElse();
  }
}

abstract class _Open implements OpenEvent {
  const factory _Open() = _$_Open;
}

/// @nodoc
class _$OpenStateTearOff {
  const _$OpenStateTearOff();

  _Initial initial() {
    return const _Initial();
  }

  _SaveCurrent saveCurrent() {
    return const _SaveCurrent();
  }

  _Opening opening() {
    return const _Opening();
  }

  _Opened opened() {
    return const _Opened();
  }

  _ErrorOpening errorOpening(String error) {
    return _ErrorOpening(
      error,
    );
  }
}

/// @nodoc
const $OpenState = _$OpenStateTearOff();

/// @nodoc
mixin _$OpenState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() saveCurrent,
    required TResult Function() opening,
    required TResult Function() opened,
    required TResult Function(String error) errorOpening,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? saveCurrent,
    TResult Function()? opening,
    TResult Function()? opened,
    TResult Function(String error)? errorOpening,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? saveCurrent,
    TResult Function()? opening,
    TResult Function()? opened,
    TResult Function(String error)? errorOpening,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_SaveCurrent value) saveCurrent,
    required TResult Function(_Opening value) opening,
    required TResult Function(_Opened value) opened,
    required TResult Function(_ErrorOpening value) errorOpening,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_SaveCurrent value)? saveCurrent,
    TResult Function(_Opening value)? opening,
    TResult Function(_Opened value)? opened,
    TResult Function(_ErrorOpening value)? errorOpening,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_SaveCurrent value)? saveCurrent,
    TResult Function(_Opening value)? opening,
    TResult Function(_Opened value)? opened,
    TResult Function(_ErrorOpening value)? errorOpening,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $OpenStateCopyWith<$Res> {
  factory $OpenStateCopyWith(OpenState value, $Res Function(OpenState) then) =
      _$OpenStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$OpenStateCopyWithImpl<$Res> implements $OpenStateCopyWith<$Res> {
  _$OpenStateCopyWithImpl(this._value, this._then);

  final OpenState _value;
  // ignore: unused_field
  final $Res Function(OpenState) _then;
}

/// @nodoc
abstract class _$InitialCopyWith<$Res> {
  factory _$InitialCopyWith(_Initial value, $Res Function(_Initial) then) =
      __$InitialCopyWithImpl<$Res>;
}

/// @nodoc
class __$InitialCopyWithImpl<$Res> extends _$OpenStateCopyWithImpl<$Res>
    implements _$InitialCopyWith<$Res> {
  __$InitialCopyWithImpl(_Initial _value, $Res Function(_Initial) _then)
      : super(_value, (v) => _then(v as _Initial));

  @override
  _Initial get _value => super._value as _Initial;
}

/// @nodoc

class _$_Initial implements _Initial {
  const _$_Initial();

  @override
  String toString() {
    return 'OpenState.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _Initial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() saveCurrent,
    required TResult Function() opening,
    required TResult Function() opened,
    required TResult Function(String error) errorOpening,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? saveCurrent,
    TResult Function()? opening,
    TResult Function()? opened,
    TResult Function(String error)? errorOpening,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? saveCurrent,
    TResult Function()? opening,
    TResult Function()? opened,
    TResult Function(String error)? errorOpening,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_SaveCurrent value) saveCurrent,
    required TResult Function(_Opening value) opening,
    required TResult Function(_Opened value) opened,
    required TResult Function(_ErrorOpening value) errorOpening,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_SaveCurrent value)? saveCurrent,
    TResult Function(_Opening value)? opening,
    TResult Function(_Opened value)? opened,
    TResult Function(_ErrorOpening value)? errorOpening,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_SaveCurrent value)? saveCurrent,
    TResult Function(_Opening value)? opening,
    TResult Function(_Opened value)? opened,
    TResult Function(_ErrorOpening value)? errorOpening,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _Initial implements OpenState {
  const factory _Initial() = _$_Initial;
}

/// @nodoc
abstract class _$SaveCurrentCopyWith<$Res> {
  factory _$SaveCurrentCopyWith(
          _SaveCurrent value, $Res Function(_SaveCurrent) then) =
      __$SaveCurrentCopyWithImpl<$Res>;
}

/// @nodoc
class __$SaveCurrentCopyWithImpl<$Res> extends _$OpenStateCopyWithImpl<$Res>
    implements _$SaveCurrentCopyWith<$Res> {
  __$SaveCurrentCopyWithImpl(
      _SaveCurrent _value, $Res Function(_SaveCurrent) _then)
      : super(_value, (v) => _then(v as _SaveCurrent));

  @override
  _SaveCurrent get _value => super._value as _SaveCurrent;
}

/// @nodoc

class _$_SaveCurrent implements _SaveCurrent {
  const _$_SaveCurrent();

  @override
  String toString() {
    return 'OpenState.saveCurrent()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _SaveCurrent);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() saveCurrent,
    required TResult Function() opening,
    required TResult Function() opened,
    required TResult Function(String error) errorOpening,
  }) {
    return saveCurrent();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? saveCurrent,
    TResult Function()? opening,
    TResult Function()? opened,
    TResult Function(String error)? errorOpening,
  }) {
    return saveCurrent?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? saveCurrent,
    TResult Function()? opening,
    TResult Function()? opened,
    TResult Function(String error)? errorOpening,
    required TResult orElse(),
  }) {
    if (saveCurrent != null) {
      return saveCurrent();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_SaveCurrent value) saveCurrent,
    required TResult Function(_Opening value) opening,
    required TResult Function(_Opened value) opened,
    required TResult Function(_ErrorOpening value) errorOpening,
  }) {
    return saveCurrent(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_SaveCurrent value)? saveCurrent,
    TResult Function(_Opening value)? opening,
    TResult Function(_Opened value)? opened,
    TResult Function(_ErrorOpening value)? errorOpening,
  }) {
    return saveCurrent?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_SaveCurrent value)? saveCurrent,
    TResult Function(_Opening value)? opening,
    TResult Function(_Opened value)? opened,
    TResult Function(_ErrorOpening value)? errorOpening,
    required TResult orElse(),
  }) {
    if (saveCurrent != null) {
      return saveCurrent(this);
    }
    return orElse();
  }
}

abstract class _SaveCurrent implements OpenState {
  const factory _SaveCurrent() = _$_SaveCurrent;
}

/// @nodoc
abstract class _$OpeningCopyWith<$Res> {
  factory _$OpeningCopyWith(_Opening value, $Res Function(_Opening) then) =
      __$OpeningCopyWithImpl<$Res>;
}

/// @nodoc
class __$OpeningCopyWithImpl<$Res> extends _$OpenStateCopyWithImpl<$Res>
    implements _$OpeningCopyWith<$Res> {
  __$OpeningCopyWithImpl(_Opening _value, $Res Function(_Opening) _then)
      : super(_value, (v) => _then(v as _Opening));

  @override
  _Opening get _value => super._value as _Opening;
}

/// @nodoc

class _$_Opening implements _Opening {
  const _$_Opening();

  @override
  String toString() {
    return 'OpenState.opening()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _Opening);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() saveCurrent,
    required TResult Function() opening,
    required TResult Function() opened,
    required TResult Function(String error) errorOpening,
  }) {
    return opening();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? saveCurrent,
    TResult Function()? opening,
    TResult Function()? opened,
    TResult Function(String error)? errorOpening,
  }) {
    return opening?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? saveCurrent,
    TResult Function()? opening,
    TResult Function()? opened,
    TResult Function(String error)? errorOpening,
    required TResult orElse(),
  }) {
    if (opening != null) {
      return opening();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_SaveCurrent value) saveCurrent,
    required TResult Function(_Opening value) opening,
    required TResult Function(_Opened value) opened,
    required TResult Function(_ErrorOpening value) errorOpening,
  }) {
    return opening(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_SaveCurrent value)? saveCurrent,
    TResult Function(_Opening value)? opening,
    TResult Function(_Opened value)? opened,
    TResult Function(_ErrorOpening value)? errorOpening,
  }) {
    return opening?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_SaveCurrent value)? saveCurrent,
    TResult Function(_Opening value)? opening,
    TResult Function(_Opened value)? opened,
    TResult Function(_ErrorOpening value)? errorOpening,
    required TResult orElse(),
  }) {
    if (opening != null) {
      return opening(this);
    }
    return orElse();
  }
}

abstract class _Opening implements OpenState {
  const factory _Opening() = _$_Opening;
}

/// @nodoc
abstract class _$OpenedCopyWith<$Res> {
  factory _$OpenedCopyWith(_Opened value, $Res Function(_Opened) then) =
      __$OpenedCopyWithImpl<$Res>;
}

/// @nodoc
class __$OpenedCopyWithImpl<$Res> extends _$OpenStateCopyWithImpl<$Res>
    implements _$OpenedCopyWith<$Res> {
  __$OpenedCopyWithImpl(_Opened _value, $Res Function(_Opened) _then)
      : super(_value, (v) => _then(v as _Opened));

  @override
  _Opened get _value => super._value as _Opened;
}

/// @nodoc

class _$_Opened implements _Opened {
  const _$_Opened();

  @override
  String toString() {
    return 'OpenState.opened()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _Opened);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() saveCurrent,
    required TResult Function() opening,
    required TResult Function() opened,
    required TResult Function(String error) errorOpening,
  }) {
    return opened();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? saveCurrent,
    TResult Function()? opening,
    TResult Function()? opened,
    TResult Function(String error)? errorOpening,
  }) {
    return opened?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? saveCurrent,
    TResult Function()? opening,
    TResult Function()? opened,
    TResult Function(String error)? errorOpening,
    required TResult orElse(),
  }) {
    if (opened != null) {
      return opened();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_SaveCurrent value) saveCurrent,
    required TResult Function(_Opening value) opening,
    required TResult Function(_Opened value) opened,
    required TResult Function(_ErrorOpening value) errorOpening,
  }) {
    return opened(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_SaveCurrent value)? saveCurrent,
    TResult Function(_Opening value)? opening,
    TResult Function(_Opened value)? opened,
    TResult Function(_ErrorOpening value)? errorOpening,
  }) {
    return opened?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_SaveCurrent value)? saveCurrent,
    TResult Function(_Opening value)? opening,
    TResult Function(_Opened value)? opened,
    TResult Function(_ErrorOpening value)? errorOpening,
    required TResult orElse(),
  }) {
    if (opened != null) {
      return opened(this);
    }
    return orElse();
  }
}

abstract class _Opened implements OpenState {
  const factory _Opened() = _$_Opened;
}

/// @nodoc
abstract class _$ErrorOpeningCopyWith<$Res> {
  factory _$ErrorOpeningCopyWith(
          _ErrorOpening value, $Res Function(_ErrorOpening) then) =
      __$ErrorOpeningCopyWithImpl<$Res>;
  $Res call({String error});
}

/// @nodoc
class __$ErrorOpeningCopyWithImpl<$Res> extends _$OpenStateCopyWithImpl<$Res>
    implements _$ErrorOpeningCopyWith<$Res> {
  __$ErrorOpeningCopyWithImpl(
      _ErrorOpening _value, $Res Function(_ErrorOpening) _then)
      : super(_value, (v) => _then(v as _ErrorOpening));

  @override
  _ErrorOpening get _value => super._value as _ErrorOpening;

  @override
  $Res call({
    Object? error = freezed,
  }) {
    return _then(_ErrorOpening(
      error == freezed
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_ErrorOpening implements _ErrorOpening {
  const _$_ErrorOpening(this.error);

  @override
  final String error;

  @override
  String toString() {
    return 'OpenState.errorOpening(error: $error)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ErrorOpening &&
            const DeepCollectionEquality().equals(other.error, error));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(error));

  @JsonKey(ignore: true)
  @override
  _$ErrorOpeningCopyWith<_ErrorOpening> get copyWith =>
      __$ErrorOpeningCopyWithImpl<_ErrorOpening>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() saveCurrent,
    required TResult Function() opening,
    required TResult Function() opened,
    required TResult Function(String error) errorOpening,
  }) {
    return errorOpening(error);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? saveCurrent,
    TResult Function()? opening,
    TResult Function()? opened,
    TResult Function(String error)? errorOpening,
  }) {
    return errorOpening?.call(error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? saveCurrent,
    TResult Function()? opening,
    TResult Function()? opened,
    TResult Function(String error)? errorOpening,
    required TResult orElse(),
  }) {
    if (errorOpening != null) {
      return errorOpening(error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_SaveCurrent value) saveCurrent,
    required TResult Function(_Opening value) opening,
    required TResult Function(_Opened value) opened,
    required TResult Function(_ErrorOpening value) errorOpening,
  }) {
    return errorOpening(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_SaveCurrent value)? saveCurrent,
    TResult Function(_Opening value)? opening,
    TResult Function(_Opened value)? opened,
    TResult Function(_ErrorOpening value)? errorOpening,
  }) {
    return errorOpening?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_SaveCurrent value)? saveCurrent,
    TResult Function(_Opening value)? opening,
    TResult Function(_Opened value)? opened,
    TResult Function(_ErrorOpening value)? errorOpening,
    required TResult orElse(),
  }) {
    if (errorOpening != null) {
      return errorOpening(this);
    }
    return orElse();
  }
}

abstract class _ErrorOpening implements OpenState {
  const factory _ErrorOpening(String error) = _$_ErrorOpening;

  String get error;
  @JsonKey(ignore: true)
  _$ErrorOpeningCopyWith<_ErrorOpening> get copyWith =>
      throw _privateConstructorUsedError;
}
